1)SELECTION SORT
Определение: На каждом шаге алгоритма находят минимальный элемент среди последних и меняют его местами с текущим элементом в массиве.
Принцип работы:
1. Массив мысленно делится на две части: отсортированную (слева) и неотсортированную (справа)
2. Изначально отсортированная часть пуста, неотсортированная - весь массив
3. На каждом шаге алгоритм:
- Находит минимальный элемент в неотсортированной части
- Меняет его местами с первым элементом неотсортированной части
- Увеличивает отсортированную часть на один элемент
4. Процесс повторяется, пока неотсортированная часть не станет пустой
Пример работы для массива [64, 25, 12, 22, 11]:
Шаг 1: Находим минимальный 11, меняем с 64 → [11, 25, 12, 22, 64]
Шаг 2: Находим минимальный 12, меняем с 25 → [11, 12, 25, 22, 64]
Шаг 3: Находим минимальный 22, меняем с 25 → [11, 12, 22, 25, 64]
Шаг 4: Массив отсортирован
Временная сложность: O(n²)
Объяснение сложности:
-Внешний цикл выполняется n-1 раз
-Внутренний цикл на i-ой итерации выполняет n-i-1 сравнений
-Общее количество сравнений: (n-1) + (n-2) + ... + 1 = n(n-1)/2
-Это составляет O(n²) операций сравнения
-Количество обменов: всегда n-1, что составляет O(n)
2)BUBBLE SORT
Определение: Алгоритм проходит по списку несколько раз, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном порядке. Процесс повторяется до тех пор, пока список полностью не отсортируется.
Принцип работы:
1. Алгоритм многократно проходит по массиву от начала до конца
2. На каждом проходе сравнивает соседние элементы попарно
3. Если левый элемент больше правого, меняет их местами
4. После каждого прохода самый большой элемент "всплывает" в конец массива
5. Процесс повторяется для оставшейся неотсортированной части
Пример работы для массива [5, 1, 4, 2, 8]:
Проход 1: 5>1 → обмен → [1, 5, 4, 2, 8]; 5>4 → обмен → [1, 4, 5, 2, 8]; 5>2 → обмен → [1, 4, 2, 5, 8]
Проход 2: 4>2 → обмен → [1, 2, 4, 5, 8]
Проход 3: Обменов нет - массив отсортирован
Временная сложность: O(n²)
Объяснение сложности:
-В худшем случае (обратно отсортированный массив) выполняется максимальное количество операций
-Количество сравнений: (n-1) + (n-2) + ... + 1 = n(n-1)/2 ≈ O(n²)
-В лучшем случае (уже отсортированный массив с оптимизацией): O(n)
-Средний случай: O(n²)
3)INSERTION SORT
Определение: Алгоритм строит отсортированную часть списка, постепенно вставляя каждый элемент на своё место. Он начинает с первого элемента и перемещается вправо, сравнивая каждый элемент с предыдущими элементами и вставляя его на правильное место.
Принцип работы:
1. Массив делится на отсортированную (слева) и неотсортированную (справа) части
2. Изначально отсортированная часть содержит только первый элемент
3. Для каждого следующего элемента из неотсортированной части:
-Сохраняем его значение как "ключевой элемент"
-Сравниваем ключевой элемент с элементами отсортированной части справа налево
-Сдвигаем все элементы большие ключевого на одну позицию вправо
-Вставляем ключевой элемент на освободившееся место
4. После каждой итерации отсортированная часть увеличивается на один элемент
Пример работы для массива [12, 11, 13, 5, 6]:
-Элемент 11: сравниваем с 12, сдвигаем 12, вставляем 11 → [11, 12, 13, 5, 6]
-Элемент 13: остается на месте → [11, 12, 13, 5, 6]
-Элемент 5: сдвигаем 13, 12, 11, вставляем 5 → [5, 11, 12, 13, 6]
-Элемент 6: сдвигаем 13, 12, 11, вставляем 6 → [5, 6, 11, 12, 13]
Временная сложность: O(n²)
Объяснение сложности:
-В худшем случае (обратно отсортированный массив): O(n²)
-Для каждого элемента нужно сдвигать все предыдущие элементы
-Количество операций: 1 + 2 + 3 + ... + (n-1) = n(n-1)/2
-В лучшем случае (уже отсортированный массив): O(n)
-Для каждого элемента выполняется только одно сравнение
-Средний случай: O(n²)
4)MERGE SORT
Определение: Алгоритм состоит в разделении массива пополам, сортировке половин и их слиянии.
Принцип работы:
1. Разделение: Массив рекурсивно делится пополам до тех пор, пока не останутся подмассивы длиной 1 элемент
2. Базовый случай: Массив из одного элемента считается отсортированным
3. Слияние: Отсортированные подмассивы сливаются в большие отсортированные массивы:
-Сравниваются первые элементы двух подмассивов
-Меньший элемент добавляется в результирующий массив
-Процесс повторяется пока оба подмассива не будут полностью обработаны
4. Рекурсия: Процесс повторяется рекурсивно для всех уровней разделения
Пример работы для массива [38, 27, 43, 3]:
-Разделение: [38, 27] и [43, 3]
-Рекурсивное разделение: [38], [27], [43], [3]
-Слияние: [27, 38] и [3, 43]
-Финальное слияние: [3, 27, 38, 43]
Временная сложность: O(n log n)
Объяснение сложности:
-Глубина рекурсии: Массив делится пополам на log₂n уровней
-Работа на каждом уровне: На каждом уровне выполняется слияние всех элементов (n операций)
-Общая сложность: O(n) операций на каждом из O(log n) уровней = O(n log n)
-Сложность одинакова для худшего, среднего и лучшего случаев
SHELL SORT
Определение: Является модификацией сортировки вставками, сортирует между собой элементы, стоящие на местах, кратных определённому шагу.
Принцип работы:
1. Последовательность промежутков: Используется убывающая последовательность шагов (gap)
2. Сортировка с шагом: На каждом шаге алгоритм:
-Сортирует элементы, отстоящие друг от друга на расстоянии gap
-Использует модифицированную сортировку вставками для этих элементов
3. Уменьшение шага: Шаг gap уменьшается до тех пор, пока не станет равным 1
4. Финальная сортировка: При gap=1 выполняется обычная сортировка вставками
Пример работы для массива [12, 34, 54, 2, 3] с начальным gap=2:
-Gap=2: Сортируем элементы с индексами 0-2-4 и 1-3
-Gap=1: Выполняем обычную сортировку вставками
Временная сложность: Зависит от выбора последовательности
Объяснение сложности:
-Худший случай: O(n²) - при неудачном выборе последовательности
-Лучший случай: O(n log n) - при оптимальной последовательности
-Практическая сложность: O(n^(3/2)) для последовательности Кнута
-Сложность аналитически трудно вычислима, зависит от последовательности шагов
6)QUICK SORT
Определение: Алгоритм состоит в выборе опорного элемента, разделении массива на две части относительно опорного (одна — все элементы, меньшие опорного элемента, вторая — большие), и в сортировке полученных частей рекурсивным вызовом себя от них.
Принцип работы:
1. Выбор опоры: Выбирается опорный элемент (pivot)
2. Разделение: Массив перестраивается так, что:
-Все элементы меньше опоры перемещаются слева от нее
-Все элементы больше опоры перемещаются справа от нее
-Опорный элемент оказывается на своем окончательном месте
3. Рекурсия: Рекурсивно применяется тот же алгоритм к левой и правой частям
4. Базовый случай: Массивы длиной 0 или 1 считаются отсортированными
Пример работы для массива [10, 7, 8, 9, 1, 5] с опорой 5:
-Разделение: [1, 5, 8, 9, 10, 7] → элементы меньше 5 слева, больше - справа
-Рекурсия для левой [1] и правой [8, 9, 10, 7] частей
Временная сложность: O(n log n) в среднем, O(n²) в худшем случае**
Объяснение сложности:
-Средний случай: O(n log n) - при случайном выборе опоры
-Глубина рекурсии: O(log n)
-Работа на каждом уровне: O(n)
-Худший случай: O(n²) - когда опора всегда минимальный или максимальный элемент
-Происходит при уже отсортированном массиве с неудачным выбором опоры
-Лучший случай: O(n log n) - при равномерном разделении
7)HEAP SORT
Определение: Алгоритм строит кучу из исходного списка, затем постепенно извлекает наибольший элемент из кучи и помещает его в конец списка.
Принцип работы:
1. Построение кучи: Преобразование массива в max-heap (бинарное дерево, где каждый родитель больше своих потомков)
2. Извлечение максимума: 
-Максимальный элемент (корень) перемещается в конец массива
-Размер кучи уменьшается на 1
-Восстанавливается свойство max-heap для уменьшенной кучи
3. Повторение: Процесс повторяется пока куча не опустеет
Пример работы для массива [12, 11, 13, 5, 6, 7]:
-Построение max-heap: [13, 11, 12, 5, 6, 7]
-Извлекаем 13 в конец: [12, 11, 7, 5, 6 | 13]
-Восстанавливаем кучу и повторяем
Временная сложность: O(n log n)
Объяснение сложности:
-Построение кучи: O(n) операций
-Извлечение элементов: n раз по O(log n) операций
-Общая сложность: O(n) + O(n log n) = O(n log n)
-Сложность одинакова для всех случаев (худшего, среднего, лучшего)
8)LINEAR SEARCH
Определение: Простейший вид поиска заданного элемента на некотором множестве. Осуществляется путём последовательного сравнения очередного рассматриваемого значения с искомым до тех пор, пока эти значения не совпадут.
Принцип работы:
1. Начинаем с первого элемента массива
2. Последовательно сравниваем каждый элемент с искомым значением
3. Если элемент найден - возвращаем его индекс
4. Если дошли до конца массива и не нашли - возвращаем -1
Временная сложность: O(n)
Объяснение сложности:
-Худший случай: O(n) - элемент в конце массива или отсутствует
-Лучший случай: O(1) - элемент в начале массива
-Средний случай: O(n) - в среднем нужно проверить n/2 элементов
9)BINARY SEARCH
Определение: Поиск заданного элемента на упорядоченном множестве, осуществляемый путём неоднократного деления этого множества на две части таким образом, что искомый элемент попадает в одну из этих частей.
Принцип работы:
1. Определяем границы поиска (начало и конец массива)
2. Находим средний элемент
3. Сравниваем средний элемент с искомым:
-Если равны - поиск завершен
-Если искомый меньше - ищем в левой половине
-Если искомый больше - ищем в правой половине
4. Повторяем пока границы поиска не пересекутся
Временная сложность: O(log n)
Объяснение сложности:
-На каждом шаге область поиска уменьшается вдвое
-Максимальное количество шагов: log₂n
-Сложность одинакова для всех случаев
10)INTERPOLATION SEARCH
Определение: Алгоритм поиска для отсортированных наборов данных, который предсказывает позицию нужного элемента на основе разницы значений.
Принцип работы:
1. Использует формулу интерполяции для предсказания позиции элемента
2. Предполагает равномерное распределение данных в массиве
3. Работает аналогично бинарному поиску, но выбирает точку деления на основе значений
4. Более эффективен чем бинарный поиск для равномерно распределенных данных
Временная сложность: O(log log n) в среднем, O(n) в худшем случае
Объяснение сложности:
-Средний случай: O(log log n) - для равномерно распределенных данных
-Худший случай: O(n) - для неравномерно распределенных данных
-Эффективность сильно зависит от распределения данных
11)FIBONACCI SEARCH
Определение: Эффективный алгоритм поиска, используемый для нахождения целевого значения в отсортированной коллекции, который использует числа Фибоначчи для определения позиций для сравнения.
Принцип работы:
1. Использует числа Фибоначчи для определения позиций сравнения
2. Работает с тремя последовательными числами Фибоначчи
3. Сравнивает элемент с ключом и сужает область поиска
4. Эффективен для больших массивов и работает без деления
Временная сложность: O(log n)
Объяснение сложности:
-Алгоритм делит массив на части используя числа Фибоначчи
-Количество шагов пропорционально log n
-Сложность сравнима с бинарным поиском но с другими константами
